<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> js基础夯实-call,apply,bind · Leo's Blog</title><meta name="description" content="js基础夯实-call,apply,bind - Tauleos"><meta name="google-site-verification" content="y-sRxe2Toq8nFRU8PiEYywkdUoWdk_UYysZDKbnM7Ck"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://tauleos.github.io/atom.xml" title="Leo's Blog"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Leo's Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">HOME</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVES</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">TAGS</a></li><li class="nav-list-item"><a href="https://github.com/Tauleos" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">js基础夯实-call,apply,bind</h1><div class="post-info">2019年4月12日</div><div class="post-content"><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><blockquote>
<p><code>call、apply、bind</code> 本质都是改变 <code>this</code> 的指向，不同点 <code>call、apply</code> 是直接调用函数，<code>bind</code> 是返回一个新的函数。<code>call</code> 跟 <code>apply</code> 就只有参数上不同。</p>
<blockquote>
<p>区别就是<code>call()</code>方法接受的是参数列表，而<code>apply()</code>方法接受的是一个参数数组。</p>
</blockquote>
</blockquote>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>箭头函数的 <code>this</code> 永远指向它所在的作用域</li>
<li>函数作为构造函数用 <code>new</code> 关键字调用时，不应该改变其 <code>this</code> 指向，因为 <code>new绑定</code> 的优先级高于 <code>显示绑定</code> 和 <code>硬绑定</code></li>
</ul>
<p>代码实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">&#x27;must be a function&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拿到参数传给调用者</span></span><br><span class="line">  <span class="keyword">const</span> self = <span class="built_in">this</span>,</span><br><span class="line">  <span class="comment">// 构建一个干净的函数，用于保存原函数的原型</span></span><br><span class="line">  nop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="comment">// 绑定的函数</span></span><br><span class="line">  bound = <span class="function"><span class="keyword">function</span> (<span class="params">...selfArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.apply(</span><br><span class="line">      <span class="comment">// this instanceof nop, 判断是否使用 new 来调用 bound</span></span><br><span class="line">      <span class="comment">// 如果是 new 来调用的话，this的指向就是其实例，</span></span><br><span class="line">      <span class="comment">// 如果不是 new 调用的话，就改变 this 指向到指定的对象 o</span></span><br><span class="line">      <span class="built_in">this</span> <span class="keyword">instanceof</span> nop ? <span class="built_in">this</span> : thisArg,</span><br><span class="line">      args.concat(selfArgs)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 箭头函数没有 prototype，箭头函数this永远指向它所在的作用域</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.prototype) &#123;</span><br><span class="line">    nop.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 修改绑定函数的原型指向</span></span><br><span class="line">  bound.prototype = <span class="keyword">new</span> nop();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.prototype.name = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">  name: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bound = bar.mybind(foo, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>);</span><br><span class="line"><span class="keyword">new</span> bound(); <span class="comment">// bar, [22, 33, 44]</span></span><br><span class="line">bound(); <span class="comment">// foo, [22, 33, 44]</span></span><br></pre></td></tr></table></figure>
<h2 id="Call-amp-Apply"><a href="#Call-amp-Apply" class="headerlink" title="Call &amp; Apply"></a>Call &amp; Apply</h2><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><blockquote>
<p><code>bind</code> 是封装了 <code>call</code> 的方法改变了 <code>this</code> 的指向并返回一个新的函数，那么 <code>call</code> 是如何做到改变 <code>this</code> 的指向呢？原理很简单，在方法调用模式下，<code>this</code> 总是指向调用它所在方法的对象，<code>this</code> 的指向与所在方法的调用位置有关，而与方法的声明位置无关（箭头函数特殊）。先写一个小 demo 来理解一下下。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">foo.fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 this 指向了 foo</span></span><br><span class="line">  <span class="comment">// 因为 foo 调用了 fn，</span></span><br><span class="line">  <span class="comment">// fn 的 this 就指向了调用它所在方法的对象 foo 上</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// foo</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以利用<code>this</code>的这个特性来实现call</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	thisArg = thisArg || <span class="built_in">window</span>;</span><br><span class="line">	<span class="comment">// 将调用call函数的对象添加到thisArg的属性中</span></span><br><span class="line">	thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line">	<span class="keyword">const</span> result = thisArg.fn(...args);</span><br><span class="line">	<span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	thisArg = thisArg || <span class="built_in">window</span>;</span><br><span class="line">	thisArg.fn = <span class="built_in">this</span>;</span><br><span class="line">	<span class="keyword">const</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">const</span> result = thisArg.fn(...args);</span><br><span class="line">	<span class="keyword">delete</span> thisArg.fn;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.prototype.name = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">	name: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar.myCall(foo, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// foo [1, 2, 3]</span></span><br><span class="line">bar.myApply(foo, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// foo [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>完~<br><br><br>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Qqh1H-2MUyVGoWjgOstQrg">干货！阿里P6手写源码面试题集锦</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/3710a8c65723.html" class="prev">上一篇</a><a href="/a74d1e8039ab.html" class="next">下一篇</a></div><div id="gitalk-container"></div><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" async></script><script src="https://cdnjs.cloudflare.com/ajax/libs/blueimp-md5/2.10.0/js/md5.min.js" async></script><script>var ds = document.createElement('link');
ds.rel = 'stylesheet';ds.async = true;
ds.href = 'https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css';
(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
window.onload = function() {
  var gitalk = new Gitalk({
    clientID: '62e01f3aa3f140c5af8a',
    clientSecret: '8f02698609ba488706c5e67839f0bbf46861554f',
    repo: 'Tauleos.github.io',
    owner: 'Tauleos',
    admin: ['Tauleos'],
    id: md5(window.location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container');
}</script><div class="copyright"><p id="host_by"><span id="busuanzi_container_site_pv">&nbsp;本站总访问量 &nbsp;<span id="busuanzi_value_site_pv"><i class="fa fa-spinner"></i></span> 次,</span><span id="busanzi_container_site_uv">&nbsp;本站总访问人数 &nbsp;<span id="busuanzi_value_site_uv"><i class="fa fa-spinner"></i></span> 次.</span></p><p>© 2017 - 2020 created by <a href="https://tauleos.github.io">Tauleos</a>,Looking for better life and peace.</p><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script></div></footer></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body></html>